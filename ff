<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>스캘핑 시그널 (완성본)</title>

<style>
:root{
  --bg:#0b1220; --panel:#0f172a; --line:#1f2a44; --muted:#94a3b8;
  --green:#22c55e; --red:#ef4444; --blue:#2563eb; --yellow:#eab308;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:#e5e7eb;font-family:Arial,sans-serif}

.top{
  display:flex;gap:10px;align-items:center;justify-content:space-between;
  padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--line)
}
.left{display:flex;flex-direction:column;gap:2px}
.sym{font-weight:900}
.price{font-size:13px;color:var(--muted)}
.mid{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
button, input{font-family:inherit}
button.tf, button.action{
  padding:7px 10px;border-radius:10px;border:1px solid var(--line);
  background:#0b1220;color:#e5e7eb;font-weight:800;cursor:pointer
}
button.tf.active{border-color:var(--blue);outline:1px solid rgba(37,99,235,.35)}
button.action{border-color:#334155}
button.warn{border-color:rgba(234,179,8,.6)}
.right{font-size:13px;text-align:right;display:flex;flex-direction:column;gap:4px}
#posSide{font-weight:900}
#posEntry{font-weight:900}

.controls{
  display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:flex-end
}
.ctrl{
  display:flex;gap:6px;align-items:center;
  padding:6px 10px;border:1px solid var(--line);border-radius:999px;
  background:rgba(2,6,23,.35);font-size:12px;color:var(--muted)
}
.ctrl input{
  width:64px;padding:4px 6px;border-radius:8px;border:1px solid #334155;
  background:#020617;color:#e5e7eb
}

#chart{width:100%;height:58vh;min-height:320px;background:#020617}
#rsi{width:100%;height:18vh;min-height:140px;background:#020617;border-top:1px solid var(--line)}

#logBox{
  height:180px;overflow:auto;background:#020617;border-top:1px solid var(--line);
  padding:8px 10px;font-size:12px;line-height:1.6
}
.logRow{padding:4px 6px;border-radius:8px;cursor:pointer}
.logRow:hover{background:rgba(148,163,184,.10)}
.tag{font-weight:900}
.tag.long{color:var(--green)}
.tag.short{color:var(--red)}
.tag.exit{color:var(--yellow)}
.muted{color:var(--muted)}
</style>
</head>

<body>
<div class="top">
  <div class="left">
    <div class="sym">BTCUSDT</div>
    <div class="price">현재가: <b id="last">-</b></div>
    <div class="price">상태: <b id="status">초기화중...</b></div>
  </div>

  <div class="mid">
    <button class="tf" data-tf="1s">1s</button>
    <button class="tf active" data-tf="1m">1m</button>
    <button class="tf" data-tf="5m">5m</button>
    <button class="action warn" id="btnExit">포지션 종료(청산)</button>
  </div>

  <div class="right">
    <div>포지션: <b id="posSide">없음</b></div>
    <div>진입가: <b id="posEntry">-</b></div>
    <div class="controls">
      <div class="ctrl">TP% <input id="tpPct" type="number" step="0.1" value="0.5"></div>
      <div class="ctrl">SL% <input id="slPct" type="number" step="0.1" value="0.3"></div>
    </div>
  </div>
</div>

<div id="chart"></div>
<div id="rsi"></div>
<div id="logBox"><div class="muted">신호 로그(줄): LONG/SHORT/EXIT가 여기에 쌓입니다. (줄 클릭 시 해당 시점으로 이동)</div></div>

<script>
/* ===== 화면 요소 ===== */
const statusEl = document.getElementById('status');
const lastEl   = document.getElementById('last');
const logBox   = document.getElementById('logBox');
const tpInput  = document.getElementById('tpPct');
const slInput  = document.getElementById('slPct');
const btnExit  = document.getElementById('btnExit');

/* ===== 에러 표시 ===== */
window.addEventListener('error', (e)=>{ statusEl.textContent = 'JS 에러: ' + (e.message || ''); });
window.addEventListener('unhandledrejection', ()=>{ statusEl.textContent = 'Promise 에러'; });

/* ===== 라이브러리 로드 ===== */
function loadScript(src){
  return new Promise((res,rej)=>{
    const s=document.createElement('script');
    s.src=src; s.onload=res; s.onerror=()=>rej(new Error('load fail: '+src));
    document.head.appendChild(s);
  });
}

(async function boot(){
  statusEl.textContent = '차트 라이브러리 로딩중...';
  const sources = [
    'https://cdn.jsdelivr.net/npm/lightweight-charts@5.0.1/dist/lightweight-charts.standalone.production.js',
    'https://unpkg.com/lightweight-charts@5.0.1/dist/lightweight-charts.standalone.production.js',
    'https://cdn.jsdelivr.net/npm/lightweight-charts/dist/lightweight-charts.standalone.production.js',
    'https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js',
  ];
  let ok=false;
  for(const src of sources){
    try{
      await loadScript(src);
      if(window.LightweightCharts){ ok=true; break; }
    }catch(e){}
  }
  if(!ok){ statusEl.textContent='차트 라이브러리 로드 실패(CDN 차단/네트워크)'; return; }
  statusEl.textContent='차트 라이브러리 OK';
  startApp();
})();

/* ===== 앱 ===== */
function startApp(){
  const chartEl = document.getElementById('chart');
  const chart = LightweightCharts.createChart(chartEl, {
    width: chartEl.clientWidth || window.innerWidth,
    height: chartEl.clientHeight || 320,
    layout:{background:{color:'#020617'},textColor:'#cbd5f5'},
    grid:{vertLines:{color:'#1e293b'},horzLines:{color:'#1e293b'}},
    timeScale:{timeVisible:true,secondsVisible:false},
    rightPriceScale:{borderColor:'#1e293b'}
  });
  const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries,{
    upColor:'#26a69a',downColor:'#ef5350',borderVisible:false,
    wickUpColor:'#26a69a',wickDownColor:'#ef5350'
  });
  const ema20Series  = chart.addSeries(LightweightCharts.LineSeries,{lineWidth:2,color:'#60a5fa'});
  const ema50Series  = chart.addSeries(LightweightCharts.LineSeries,{lineWidth:2,color:'#a78bfa'});
  const ema200Series = chart.addSeries(LightweightCharts.LineSeries,{lineWidth:2,color:'#facc15'});

  const rsiEl = document.getElementById('rsi');
  const rsiChart = LightweightCharts.createChart(rsiEl, {
    width: rsiEl.clientWidth || window.innerWidth,
    height: rsiEl.clientHeight || 140,
    layout:{background:{color:'#020617'},textColor:'#cbd5f5'},
    grid:{vertLines:{color:'#1e293b'},horzLines:{color:'#1e293b'}},
    timeScale:{timeVisible:true},
    rightPriceScale:{borderColor:'#1e293b'}
  });
  const rsiSeries = rsiChart.addSeries(LightweightCharts.LineSeries,{lineWidth:2,color:'#38bdf8'});

  function fitAll(){
    chart.resize(chartEl.clientWidth || window.innerWidth, chartEl.clientHeight || 320);
    rsiChart.resize(rsiEl.clientWidth || window.innerWidth, rsiEl.clientHeight || 140);
  }
  setTimeout(fitAll, 0); setTimeout(fitAll, 300); setTimeout(fitAll, 900);
  window.addEventListener('resize', fitAll);

  let tf='1m', wsKline=null, wsTrade=null;
  let candles=[], markers=[], cur1s=null;
  let positionSide='NONE', entryPrice=null;

  function updatePosUI(){
    const sideEl=document.getElementById('posSide');
    const entryEl=document.getElementById('posEntry');
    if(positionSide==='NONE'){ sideEl.textContent='없음'; sideEl.style.color=''; entryEl.textContent='-'; }
    else if(positionSide==='LONG'){ sideEl.textContent='LONG'; sideEl.style.color='#22c55e'; entryEl.textContent=entryPrice.toFixed(2); }
    else { sideEl.textContent='SHORT'; sideEl.style.color='#ef4444'; entryEl.textContent=entryPrice.toFixed(2); }
  }
  updatePosUI();

  function addLog(type, price, time, reason=''){
    const d=new Date(time*1000);
    const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0'), ss=String(d.getSeconds()).padStart(2,'0');
    const row=document.createElement('div'); row.className='logRow';
    let cls='muted'; if(type==='LONG') cls='tag long'; if(type==='SHORT') cls='tag short'; if(type==='EXIT') cls='tag exit';
    row.innerHTML=`<span class="muted">${hh}:${mm}:${ss}</span> | <span class="${cls}">${type}</span> | <b>${price.toFixed(2)}</b>` + (reason?` <span class="muted">(${reason})</span>`:'');
    logBox.prepend(row);
    row.addEventListener('click', ()=>{
      chart.timeScale().setVisibleRange({ from: time-60, to: time+60 });
      rsiChart.timeScale().setVisibleRange({ from: time-60, to: time+60 });
    });
  }

  function emaNext(prev, price, period){ const k=2/(period+1); return prev==null?price:(price*k+prev*(1-k)); }
  function calcRSI(closes, period=14){
    if(closes.length<period+1) return null;
    let gains=0, losses=0;
    for(let i=closes.length-period;i<closes.length;i++){
      const d=closes[i]-closes[i-1]; if(d>=0) gains+=d; else losses-=d;
    }
    const rs=gains/(losses||1); return 100-(100/(1+rs));
  }
  function near(v,t,pct=0.2){ const d=Math.abs(v-t)/t*100; return d<=pct; }
  function getTP(){ return Math.max(0, Number(tpInput.value||0))/100; }
  function getSL(){ return Math.max(0, Number(slInput.value||0))/100; }

  function placeExitMarker(time, above=true){
    markers.push({ time, position: above?'aboveBar':'belowBar', color:'#eab308', shape:'circle', text:'EXIT' });
    candleSeries.setMarkers(markers);
  }
  function exitPosition(reason, price, time){
    if(positionSide==='NONE') return;
    placeExitMarker(time, positionSide==='LONG');
    addLog('EXIT', price, time, reason);
    positionSide='NONE'; entryPrice=null; updatePosUI();
  }

  btnExit.addEventListener('click', ()=>{
    if(positionSide==='NONE') return;
    const last=candles[candles.length-1];
    const price=last?last.close:Number(lastEl.textContent||0);
    const time=last?last.time:Math.floor(Date.now()/1000);
    exitPosition('MANUAL', price, time);
  });

  function computeAndDraw(){
    if(candles.length<220) return;
    const closes=candles.map(c=>c.close);
    let e20=null,e50=null,e200=null;
    const d20=[],d50=[],d200=[],drsi=[];
    for(let i=0;i<candles.length;i++){
      const c=candles[i].close;
      e20=emaNext(e20,c,20); e50=emaNext(e50,c,50); e200=emaNext(e200,c,200);
      d20.push({time:candles[i].time,value:e20});
      d50.push({time:candles[i].time,value:e50});
      d200.push({time:candles[i].time,value:e200});
      const r=calcRSI(closes.slice(0,i+1),14); if(r!=null) drsi.push({time:candles[i].time,value:r});
    }
    ema20Series.setData(d20); ema50Series.setData(d50); ema200Series.setData(d200); rsiSeries.setData(drsi);

    const last=candles[candles.length-1];

    if(positionSide!=='NONE' && entryPrice){
      const price=last.close, tpPct=getTP(), slPct=getSL();
      if(positionSide==='LONG'){
        const tp=entryPrice*(1+tpPct), sl=entryPrice*(1-slPct);
        if(tpPct>0 && price>=tp) exitPosition('TP', price, last.time);
        else if(slPct>0 && price<=sl) exitPosition('SL', price, last.time);
      }else{
        const tp=entryPrice*(1-tpPct), sl=entryPrice*(1+slPct);
        if(tpPct>0 && price<=tp) exitPosition('TP', price, last.time);
        else if(slPct>0 && price>=sl) exitPosition('SL', price, last.time);
      }
    }

    const lastE20=d20[d20.length-1].value, lastE50=d50[d50.length-1].value, lastE200=d200[d200.length-1].value;
    const lastRSI=drsi[drsi.length-1]?.value ?? null, prevRSI=drsi[drsi.length-2]?.value ?? null;
    const rsiUp= lastRSI!=null && prevRSI!=null && lastRSI>prevRSI;
    const rsiDn= lastRSI!=null && prevRSI!=null && lastRSI<prevRSI;
    const trendUp = last.close>lastE200, trendDn = last.close<lastE200;
    const pullUp = near(last.close,lastE20,0.2)||near(last.close,lastE50,0.2);
    const pullDn = near(last.close,lastE20,0.2)||near(last.close,lastE50,0.2);
    const buy = trendUp && pullUp && lastRSI!=null && lastRSI<=40 && rsiUp;
    const sell= trendDn && pullDn && lastRSI!=null && lastRSI>=60 && rsiDn;
    const lastMarkerTime = markers.length?markers[markers.length-1].time:null;

    if(buy && lastMarkerTime!==last.time && positionSide!=='LONG'){
      if(positionSide==='SHORT') exitPosition('REVERSE', last.close, last.time);
      positionSide='LONG'; entryPrice=last.close; updatePosUI(); addLog('LONG', last.close, last.time);
      markers.push({time:last.time,position:'belowBar',color:'#22c55e',shape:'arrowUp',text:'LONG'});
      candleSeries.setMarkers(markers);
    }
    if(sell && lastMarkerTime!==last.time && positionSide!=='SHORT'){
      if(positionSide==='LONG') exitPosition('REVERSE', last.close, last.time);
      positionSide='SHORT'; entryPrice=last.close; updatePosUI(); addLog('SHORT', last.close, last.time);
      markers.push({time:last.time,position:'aboveBar',color:'#ef4444',shape:'arrowDown',text:'SHORT'});
      candleSeries.setMarkers(markers);
    }
  }

  function disconnect(){ try{wsKline?.close()}catch{} try{wsTrade?.close()}catch{} wsKline=wsTrade=null; }
  function resetAll(){
    candles=[]; markers=[]; cur1s=null;
    candleSeries.setMarkers([]); candleSeries.setData([]);
    ema20Series.setData([]); ema50Series.setData([]); ema200Series.setData([]); rsiSeries.setData([]);
    positionSide='NONE'; entryPrice=null; updatePosUI();
  }

  function connect(){
    disconnect(); resetAll(); statusEl.textContent='연결중...';
    setTimeout(fitAll,0); setTimeout(fitAll,300);

    if(tf==='1s'){
      chart.applyOptions({ timeScale:{ secondsVisible:true }});
      statusEl.textContent='1s 연결중...';
      wsTrade=new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
      wsTrade.onopen=()=>statusEl.textContent='1s 연결됨';
      wsTrade.onerror=()=>statusEl.textContent='WS 에러(차단/네트워크)';
      wsTrade.onclose=()=>statusEl.textContent='WS 종료';
      wsTrade.onmessage=(ev)=>{
        const t=JSON.parse(ev.data); const p=Number(t.p); const sec=Math.floor(Date.now()/1000);
        lastEl.textContent=p.toFixed(2);
        if(!cur1s||cur1s.sec!==sec){
          if(cur1s){
            candles.push({time:cur1s.sec,open:cur1s.open,high:cur1s.high,low:cur1s.low,close:cur1s.close});
            if(candles.length>350) candles.shift();
            candleSeries.setData(candles); computeAndDraw();
          }
          cur1s={sec,open:p,high:p,low:p,close:p};
          candleSeries.update({time:sec,open:p,high:p,low:p,close:p});
        }else{
          cur1s.high=Math.max(cur1s.high,p); cur1s.low=Math.min(cur1s.low,p); cur1s.close=p;
          candleSeries.update({time:sec,open:cur1s.open,high:cur1s.high,low:cur1s.low,close:cur1s.close});
        }
      };
    }else{
      chart.applyOptions({ timeScale:{ secondsVisible:false }});
      statusEl.textContent=tf+' 연결중...';
      wsKline=new WebSocket(`wss://stream.binance.com:9443/ws/btcusdt@kline_${tf}`);
      wsKline.onopen=()=>statusEl.textContent=tf+' 연결됨';
      wsKline.onerror=()=>statusEl.textContent='WS 에러(차단/네트워크)';
      wsKline.onclose=()=>statusEl.textContent='WS 종료';
      wsKline.onmessage=(ev)=>{
        const msg=JSON.parse(ev.data); const k=msg.k;
        const bar={time:Math.floor(k.t/1000),open:+k.o,high:+k.h,low:+k.l,close:+k.c};
        lastEl.textContent=bar.close.toFixed(2);
        const last=candles[candles.length-1];
        if(!last||last.time!==bar.time){
          candles.push(bar); if(candles.length>350) candles.shift(); candleSeries.setData(candles);
        }else{ candles[candles.length-1]=bar; candleSeries.update(bar); }
        computeAndDraw();
      };
    }
  }

  connect();
  document.querySelectorAll('button.tf').forEach(btn=>{
    btn.onclick=()=>{
      document.querySelectorAll('button.tf').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active'); tf=btn.dataset.tf; connect();
    };
  });
}
</script>
</body>
</html>